#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <fstream>
#include <mutex>
#include <string>
#include <vector>
#include <map>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

#define is_valid(c) (c >= 'a' && c <= 'z') || (c >='A' && c <= 'Z')

struct KeyVal {
    string key;
    string val;
};

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.
    // Your code goes here
    // Hints: split contents into an array of words.
    string current_word = "";
    vector<KeyVal> result_vector;
    for (int i = 0; i < content.size(); i++) {
        char current_char = content[i];
        if (is_valid(current_char)) {
            current_word += current_char;
        }
        else {
            if (current_word != "") {
                KeyVal a;
                a.key = current_word;
                a.val = "1";
                result_vector.push_back(a);
            }
            current_word = "";
        }
    }
    return result_vector;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
    // Copy your code from mr_sequential.cc here.
    int result = 0;
    for (int i = 0; i < values.size(); i++) {
        result += atoi(values[i].c_str());
    }
    return to_string(result);
}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const vector<string> &filenames);
	void doReduce(int index);
	void doSubmit(mr_tasktype taskType, int index);

	mutex mtx;
	int id;

	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::doMap(int index, const vector<string> &filenames)
{
	// Lab2: Your code goes here.
    vector <KeyVal> final_KVA;
    for (int i = 0; i < filenames.size(); i++) {
        string filename = filenames[i];
        string content;
        // Read the whole file into the buffer.
        getline(ifstream(filename), content, '\0');
        printf("id = %d filename = %s \n", cl->id(), filename.c_str());
        vector<KeyVal> current_KVA = mapf(filename, content);
        for (int j = 0; j < current_KVA.size(); j++) {
            final_KVA.push_back(current_KVA[j]);
        }
    }
    printf("map over! \n");
    ofstream out_files[REDUCER_COUNT];
    for (int i = 0; i < REDUCER_COUNT; i++) {
        out_files[i].open("mr-" + to_string(index) + "-" + to_string(i) + ".txt");
    }

    for (int i = 0; i < final_KVA.size(); i++) {
        string key = final_KVA[i].key;
        string val = final_KVA[i].val;
        int hash_result = (key[0] % REDUCER_COUNT);
        out_files[hash_result] << key << " "<< val << '\n';
    }
    for (int i = 0; i < REDUCER_COUNT; i++) {
        out_files[i].close();
    }
}

void Worker::doReduce(int index) {
	// Lab2: Your code goes here.
    map<string, int> result_map;
    for (int i = 0; i <= 5; i++) {
        ifstream in_file;
        string file_path = "mr-" + to_string(i) + '-' + to_string(index) + ".txt";
        in_file.open(file_path, ios::in);
        string content;
        getline(in_file, content, '\0');
        if (content == "") {
            continue;
        }
        stringstream ss(content);
        string word, times;
        while(ss >> word >> times){
            if (word == "wrung") cout << "find!!!!!" << endl;
            map<string, int>::iterator it = result_map.find(word);
            if(it != result_map.end()) result_map[word]++;
            else result_map[word] = 1;
            if (word == "wrung") {cout << "wrung in result_map!" << result_map["wrung"] << "index  =" << index << endl;}
        }
    }
//    for(map<string, int>::iterator it = result_map.begin(); it != result_map.end(); it++) {
//        final_file << it->first << " " << it->second << endl;
//    }
    string content;
    for (const pair<string, int> &keyVal: result_map) {
        content += keyVal.first + ' ' + to_string(keyVal.second) + '\n';
    }

    ofstream final_file(basedir + "mr-out", ios::out | ios::app);
    final_file << content << endl;
    final_file.close();
}

void Worker::doSubmit(mr_tasktype taskType, int index) {
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
}

void Worker::doWork()
{
    //
    // Lab2: Your code goes here.
    // Hints: send asktask RPC call to coordinator
    // if mr_tasktype::MAP, then doMap and doSubmit
    // if mr_tasktype::REDUCE, then doReduce and doSubmit
    // if mr_tasktype::NONE, meaning currently no work is needed, then sleep
    //
	for (;;) {
        mr_protocol::AskTaskResponse reply;
        mr_protocol::status  r = cl->call(mr_protocol::asktask, cl->id(), reply);
        mr_tasktype result = (mr_tasktype)reply.result;
        if (result == mr_tasktype::MAP) {
            printf("get map task to do\n");
            vector<string> filenames;
            filenames.push_back(reply.filename);
            doMap(reply.map_id, filenames);
            doSubmit(MAP, reply.map_id);
        }
        else if (result == mr_tasktype::REDUCE) {
            printf("get reduce task to do\n");
            doReduce(reply.reduce_id);
            doSubmit(REDUCE, reply.reduce_id);
        }
        else if (result == mr_tasktype::NONE) {

            sleep(0.1);
        }
	}
}

int main(int argc, char **argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;
	
	Worker w(argv[1], argv[2], mf, rf);
	w.doWork();

	return 0;
}

